pub_date: 2011-12-24
tags: [unix, terminal]
public: no

title: term


Терминала по поводу
=====================

Технический эксперимент с pysnole_ получился хорошим.
Цель всего действа была не в том, чтобы вывести внутри
терминала картинку, а чтобы осознать, какие технические
проблемы и какой слой наследия чернобелых годов при этом
вылезает.

Слой действительно толстый и наследние - действительно
чернобелое. Категорически не понимаю этих старых пердунов,
вроде Роба Пайка и прочей уважаемой юникс-шатии, пользующихся
черно-белыми редакторами ( sam_ screenshot). Мне нужен текст,
но текст красивый, структурированный и легковоспринимающиейся.

В Vt100 нет цветов
---------------------

Внезапно, это правда. То, что указывается через ESC-последовательности,
управляющие цветом - ниразу не цвета, а *стили* отображения текста.
Терминалу указывают использовать один из -надцати *нумерованых*
цветов, а как именно он будет это трактовать - его проблемы.

С одной стороны это хорошо - десяток-другой нумерованых цветов
можно переопределить в самом терминале и получить схему, приятную своим
глазам и подходяющую для конкретного типа дисплея, освещения и цвета ногтей
оператора.

С другой стороны, более сложные системы-в-себе, вроде вима или mutt
имеют собственные механизмы установки стилей - получается отвратительная
и позорная ситуация, когда стили от гтк-шной версии вима не подходят
к его консольному исполнению, хотя нет ни единой разумной причины для
ограничения диапазона цветов на терминале с десятком разных арм-ядер,
IPS-матрицей и толстым подключением к самому себе.

В Vt100 нет пикселей
--------------------

Маленьких волшебных девочек с крылышками не живет в этом продукте
противоестественного союза печатной машинки с телефонным модемом.
Есть только брутальные знакоместа и перемещение виртуальной каретки
по виртуальному экрану. Если мне хочется увидеть в консоли риалтаймовый
график загрузки сетевого интерфейса, я увижу треш, угар и аски-графику,
хотя количество информации, которую нужно было бы переслать для
отрисовки каждой секунды информации, намного меньше, чем уходит
на один такт обновления вываода top.

Проблема с выводом графики начинается с вопроса "куда". Если я хочу
набрать в терминале команду *img* и увидеть картинку в том месте,
где бы я увидел вывод текстового файла командой cat, то очевидным
решением будет рисовать, начиная с того места, где в этом время находился
курсор, отрендерить изображение и перевести курсор на нужное количество строк
вниз. Окей, терминал знает высоту изображения, терминал знает высоту строки
и может вычислить, на сколько строк ему нужно сдвинуть курсор.

Команда ls, оперируя списком файлов, знает количество строк и столбцов
в терминале, чтобы красиво вывести листинг в две, три или несколько колонок,
но гипотетическая команда thumbs, которая точно так же выводила бы
уменьшенные копии изображений не знает ширину окна в пикселях, а если
бы знала, могла бы располагать их только на координатах, кратных
размеру одного знакоместа.

Интерфейсы
----------

Хотя текстовый терминал является самым удобным и эффективным видом
интерфейса, внутри него есть маленькие нетекстовые суб-интерфейсы,
например меню автокомлита zsh. В баше такого меню нету, потомучто
делать интерактивные элементы внутри текстового терминала - это
проклятое дело (не зря библиотека называется ncursed_).

Реализация чего-то сложного, вроде интерфейса mutt с сайдбаром
и предпросмотром письма - труд героический и результат почему-то
не всегда работает. Внутри tmux, запущенного внутри urxvt у 
меня почему-то портится интерфейс алсамикшера и mutt, но работает
вим.

Есть ли жизнь за пределами VT100
--------------------------------

Жизнь есть, но принимает странные формы. Я уже видел две - оболочка
ipython и непонятное хипстерское поделие TermKit. Термкит совершенно
непонятная и непригодная для использования штука - какие-то градиентики,
своя недореализация ls и передача команд по http, а ipython - наоборот,
рабочий инструмент и какие-то живые люди им пользуются. Но оба не
являются не просто эмуляторами VT100, они не являются терминалами вообще.

Ipython в режиме qtconsole делает вид, что является консольным приложением,
но консоль и терминал в нем прибиты друг к другу гвоздями. Да, его можно
разделить на две части (kernel и frontend), да они могу общаться друг
с другом по сети через zmq, но такой дизайн - очень большой шаг назад.

В паре шелл/терминал важная часть дизайна - это взаимозаменяемость.
Я могу открыть терминал, в нем запустить шелл и подключится к другой машине,
а оттуда подключится к третей, потом открыть внутри редактор и нормально
им пользоваться, при этом все три шелла могут быть разными, а терминал
на первой машине можно выбрать из десятка разных, доступных в дистрибуиве.

Это не работает с ipython - чтобы пролезть через три
ssh соединения мне нужно будет сначала пробросить туннели, потом
запустить на последней машине "ядро", потом на первой "фронтенд" и
тогда у меня что-то заработает, если я конечно не перепутал -L и -R
и номера портов в ту и другую сторону. В исходниках ipython даже есть
специальный хук для автоматического поднятия одного туннеля, потомучто
людям нужен такой use case, но два пришлось бы делать руками.

Что делать
------------

Расширять количество затычек и хаков в эзотерическом недокументированном
наборе ESC-кодов - явно тупиковый путь.
Отказываться от концепции текстового интерфейса в пользу графических
монстров или хипстерского веб-интерфейса - не вариант.
Сидеть без подчеркивания текста между скобочками, аватарок в консольном
твиттер-клиенте и графика загрузки в топ - надоело.

Можно попробовать определить текстовый протокол для более новой концепции
терминала.


.. _pysnole: http://github.com/muromec/pysnole
.. _sam: http:///wikipedia.org
.. _ncursed: http://google.com
